<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Панель управления</title>
    <link rel="stylesheet" href="/css/style-panel.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Дополнительные стили для скрытия элементов */
        .hidden-by-toggle {
            display: none !important;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Панель управления</h1>

    <div class="section">
        <div class="section-title">Настройки</div>

        <div class="toggle-container">
            <span class="toggle-label">Показывать панель игроков</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggle-panel" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="toggle-container" id="toggle-roles-container">
            <span class="toggle-label">Показывать игровые роли</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggle-roles" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="toggle-container">
            <span class="toggle-label">Показывать баллы игроков</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggle-scores" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="toggle-container">
            <span class="toggle-label">Начать игру</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggle-started" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="text-input-container">
            <input type="text" id="game-title" class="text-input" placeholder="Название игры">
            <button id="send-title" class="btn btn-primary">Отправить</button>
        </div>

        <div class="text-input-container">
            <input type="text" id="game-delay" class="text-input" placeholder="Задержка (delay) в секундах">
            <button id="send-delay" class="btn btn-primary">Установить задержку</button>
        </div>
    </div>

    <div class="section">
        <div class="section-title">Игроки</div>
        <div class="players-grid" id="players-container">
            <!-- Игроки будут добавлены через JavaScript -->
        </div>
    </div>

    <div class="section">
        <div class="section-title">Действия</div>
        <div class="global-actions">
            <button id="btn-reset-statuses" class="btn">Сбросить статусы</button>
            <button id="btn-reset-roles" class="btn">Сбросить роли</button>
            <button id="btn-toggle-details" class="btn">Скрыть детали игроков</button> <!-- REQ 4: New Button -->
            <button id="btn-next-game" class="btn btn-primary">Следующая игра</button>
        </div>
    </div>
</div>

<script>
    const id = '[[${id}]]';
    // REQ 3: Client-side store for checks and guesses
    const playerSpecificData = {};

    document.addEventListener('DOMContentLoaded', function () {
        const tournamentId = '[[${tournamentId}]]';
        const gameNum = '[[${gameNum}]]';
        const tableNum = '[[${tableNum}]]';
        const phase = '[[${phase}]]';
        const service = '[[${service}]]';

        // Инициализация хранилища для каждого игрока
        for (let i = 1; i <= 10; i++) {
            playerSpecificData[i] = {
                checks: [],
                guesses: []
            };
        }

        // Генерация карточек игроков
        const playersContainer = document.getElementById('players-container');
        for (let i = 1; i <= 10; i++) {
            const playerCard = createPlayerCard(i);
            playersContainer.appendChild(playerCard);
        }

        // Подключение к EventSource
        const socket = new EventSource(`/${id}/controlinfo`);

        socket.addEventListener('message', function (event) {
            console.log('Message from server:', event.data);
            if (event.data.toString().startsWith('!')) {
                let split = event.data.toString().split(/ (.*)/s);
                switch (split[0]) {
                    case '!gameinfo': {
                        const gameInfo = JSON.parse(split[1]);
                        updatePlayersData(gameInfo);
                        updateGameSettings(gameInfo);
                        populateNumberSelects(); // Populate after data is loaded.
                        // socket.close(); // Consider if you really want to close it or keep it for live updates
                        break;
                    }
                }
            }
        });

        // REQ 3: Настройка слушателей событий select для проверок и лучших ходов
        document.querySelectorAll('.check-player-select').forEach(select => {
            select.addEventListener('change', function () {
                if (this.value) {
                    const playerNum = parseInt(this.dataset.playerNum);
                    const targetPlayerNum = parseInt(this.value);
                    handlePlayerCheckAdd(playerNum, targetPlayerNum);
                    this.value = ''; // Сбросить после выбора
                }
            });
        });

        document.querySelectorAll('.guess-player-select').forEach(select => {
            select.addEventListener('change', function () {
                if (this.value) {
                    const playerNum = parseInt(this.dataset.playerNum);
                    const targetPlayerNum = parseInt(this.value);
                    // REQ 3: Allow more than 3 guesses if needed, or keep limit client-side
                    if (playerSpecificData[playerNum] && playerSpecificData[playerNum].guesses.length < 3) {
                        handlePlayerGuessAdd(playerNum, targetPlayerNum);
                    } else if (!playerSpecificData[playerNum] || !playerSpecificData[playerNum].guesses) {
                        handlePlayerGuessAdd(playerNum, targetPlayerNum); // first guess
                    } else {
                        alert('Можно указать не более 3-х лучших ходов.');
                    }
                    this.value = ''; // Сбросить после выбора
                }
            });
        });

        // --- REQ 1: Обработчики событий UI с проверкой ответа от бэкенда ---
        document.getElementById('toggle-panel').addEventListener('change', async function (e) {
            const originalValue = !e.target.checked;
            try {
                const response = await fetch(`/${id}/visibleOverlay?value=${e.target.checked}`, {method: 'POST'});
                if (!response.ok) {
                    e.target.checked = originalValue;
                    alert('Ошибка: не удалось изменить видимость панели. Статус: ' + response.status);
                }
            } catch (error) {
                e.target.checked = originalValue;
                alert('Сетевая ошибка при изменении видимости панели.');
                console.error('Error toggle-panel:', error);
            }
        });

        document.getElementById('toggle-roles').addEventListener('change', async function (e) {
            const originalValue = !e.target.checked;
            try {
                const response = await fetch(`/${id}/visibleRoles?value=${e.target.checked}`, {method: 'POST'});
                if (!response.ok) {
                    e.target.checked = originalValue;
                    alert('Ошибка: не удалось изменить видимость ролей. Статус: ' + response.status);
                }
            } catch (error) {
                e.target.checked = originalValue;
                alert('Сетевая ошибка при изменении видимости ролей.');
                console.error('Error toggle-roles:', error);
            }
        });

        document.getElementById('toggle-scores').addEventListener('change', async function (e) {
            const originalValue = !e.target.checked;
            try {
                const response = await fetch(`/${id}/visibleScores?value=${e.target.checked}`, {method: 'POST'});
                if (!response.ok) {
                    e.target.checked = originalValue;
                    alert('Ошибка: не удалось изменить видимость баллов. Статус: ' + response.status);
                }
            } catch (error) {
                e.target.checked = originalValue;
                alert('Сетевая ошибка при изменении видимости баллов.');
                console.error('Error toggle-scores:', error);
            }
        });

        document.getElementById('toggle-started').addEventListener('change', async function (e) {
            const originalValue = !e.target.checked;
            try {
                const response = await fetch(`/${id}/started?value=${e.target.checked}`, {method: 'POST'});
                if (!response.ok) {
                    e.target.checked = originalValue;
                    alert('Ошибка: не удалось изменить статус игры. Статус: ' + response.status);
                }
            } catch (error) {
                e.target.checked = originalValue;
                alert('Сетевая ошибка при изменении статуса игры.');
                console.error('Error toggle-started:', error);
            }
        });

        document.getElementById('send-title').addEventListener('click', async function () {
            const titleInput = document.getElementById('game-title');
            const title = titleInput.value.trim();
            if (title) {
                try {
                    const response = await fetch(`/${id}/text?value=${encodeURIComponent(title)}`, {method: 'POST'});
                    if (!response.ok) {
                        alert('Ошибка: не удалось отправить название игры. Статус: ' + response.status);
                    } else {
                        // titleInput.value = ''; // Опционально: очистить поле при успехе
                        alert('Название игры отправлено.');
                    }
                } catch (error) {
                    alert('Сетевая ошибка при отправке названия игры.');
                    console.error('Error send-title:', error);
                }
            }
        });

        document.getElementById('send-delay').addEventListener('click', async function () {
            const delayInput = document.getElementById('game-delay');
            const delayValue = delayInput.value.trim();
            if (delayValue && !isNaN(delayValue)) {
                try {
                    const response = await fetch(`/${id}/delay?value=${encodeURIComponent(delayValue)}`, {method: 'POST'});
                    if (!response.ok) {
                        alert('Ошибка: не удалось установить задержку. Статус: ' + response.status);
                    } else {
                        // delayInput.value = ''; // Опционально: очистить поле при успехе
                        alert('Задержка установлена.');
                    }
                } catch (error) {
                    alert('Сетевая ошибка при установке задержки.');
                    console.error('Error send-delay:', error);
                }
            } else {
                alert('Пожалуйста, введите корректное числовое значение задержки.');
            }
        });

        document.getElementById('btn-reset-statuses').addEventListener('click', async function () {
            try {
                const response = await fetch(`/${id}/resetStatuses`, {method: 'POST'});
                if (!response.ok) {
                    alert('Ошибка: не удалось сбросить статусы. Статус: ' + response.status);
                    return; // Не обновлять UI если ошибка
                }
                // Сбросить UI статусы
                document.querySelectorAll('.status-button.active').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.player-card').forEach(card => {
                    card.classList.remove('status-killed', 'status-voted', 'status-deleted', 'status-first-killed');
                });
                // REQ 3: Clear client-side guesses data and UI for all players
                for (let i = 1; i <= 10; i++) {
                    if (playerSpecificData[i]) playerSpecificData[i].guesses = [];
                    renderPlayerGuesses(i);
                }
                alert('Статусы и лучшие ходы сброшены.');
            } catch (error) {
                alert('Сетевая ошибка при сбросе статусов.');
                console.error('Error btn-reset-statuses:', error);
            }
        });

        document.getElementById('btn-reset-roles').addEventListener('click', async function () {
            try {
                const response = await fetch(`/${id}/resetRoles`, {method: 'POST'});
                if (!response.ok) {
                    alert('Ошибка: не удалось сбросить роли. Статус: ' + response.status);
                    return; // Не обновлять UI если ошибка
                }
                // Сбросить UI роли
                document.querySelectorAll('.role-button.active').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.player-card').forEach(card => {
                    card.classList.remove('role-red', 'role-black', 'role-sher', 'role-don');
                });
                // REQ 3: Clear client-side checks data and UI for all players
                for (let i = 1; i <= 10; i++) {
                    if (playerSpecificData[i]) playerSpecificData[i].checks = [];
                    renderPlayerChecks(i);
                }
                alert('Роли и проверки сброшены.');
            } catch (error) {
                alert('Сетевая ошибка при сбросе ролей.');
                console.error('Error btn-reset-roles:', error);
            }
        });

        document.getElementById('btn-next-game').addEventListener('click', async function () {
            try {
                const response = await fetch(`/${id}/next`, {method: 'POST'});
                if (response.ok) {
                    if (service && tournamentId && gameNum && tableNum && phase) {
                        window.location.replace(`/${service}/tournaments/${tournamentId}/phases/${phase}/tables/${tableNum}/games/${parseInt(gameNum) + 1}/control`);
                    } else {
                        alert('Данные для перехода на следующую игру неполные.');
                    }
                } else {
                    alert('Ошибка при переходе на следующую игру. Статус: ' + response.status);
                }
            } catch (error) {
                alert('Сетевая ошибка при переходе на следующую игру.');
                console.error('Error btn-next-game:', error);
            }
        });

        // REQ 4: Кнопка скрытия/показа деталей
        document.getElementById('btn-toggle-details').addEventListener('click', function () {
            const rolesToggleContainer = document.getElementById('toggle-roles-container');
            const playerCardElements = document.querySelectorAll('.player-card');
            const isCurrentlyHidden = rolesToggleContainer.classList.contains('hidden-by-toggle');

            if (isCurrentlyHidden) {
                rolesToggleContainer.classList.remove('hidden-by-toggle');
                playerCardElements.forEach(card => {
                    card.querySelector('.role-row')?.classList.remove('hidden-by-toggle');
                    card.querySelector('.player-checks')?.classList.remove('hidden-by-toggle');
                    card.querySelector('.player-guess')?.classList.remove('hidden-by-toggle');
                });
                this.textContent = 'Скрыть детали игроков';
            } else {
                rolesToggleContainer.classList.add('hidden-by-toggle');
                playerCardElements.forEach(card => {
                    card.querySelector('.role-row')?.classList.add('hidden-by-toggle');
                    card.querySelector('.player-checks')?.classList.add('hidden-by-toggle');
                    card.querySelector('.player-guess')?.classList.add('hidden-by-toggle');
                });
                this.textContent = 'Показать детали игроков';
            }
        });


        function populateNumberSelects() {
            document.querySelectorAll('.player-select').forEach(select => {
                const currentValue = select.value; // Сохраняем текущее значение, если есть
                select.innerHTML = ''; // Очищаем

                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.text = '-- Выбрать --'; // Короче
                select.appendChild(emptyOption);

                for (let i = 1; i <= 10; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = i;
                    select.appendChild(option);
                }
                select.value = currentValue; // Восстанавливаем значение, если оно было осмысленным
            });
        }

        function createPlayerCard(playerNum) {
            const card = document.createElement('div');
            card.className = 'player-card';
            card.dataset.playerNum = playerNum;

            // Проверки и лучший ход теперь будут рендериться функциями renderPlayerChecks/renderPlayerGuesses
            // <div className="control-row">
            //     <div className="control-button speaker" onClick="toggleSpeaker(this, ${playerNum})">
            //         <div className="control-icon icon-speaker"></div>
            //     </div>
            // </div>;
            card.innerHTML = `
                <div class="player-header">
                    <div class="player-number">${playerNum}</div>
                    <div class="player-name" id="player-name-${playerNum}">Игрок ${playerNum}</div>
                </div>
                <div class="player-controls">
                    <div class="control-row status-row">
                        <div class="control-button status-button" data-status="first-killed" onclick="toggleStatus(this, ${playerNum}, 'first-killed')"><div class="control-icon icon-first-killed"></div></div>
                        <div class="control-button status-button" data-status="killed" onclick="toggleStatus(this, ${playerNum}, 'killed')"><div class="control-icon icon-killed"></div></div>
                        <div class="control-button status-button" data-status="voted" onclick="toggleStatus(this, ${playerNum}, 'voted')"><div class="control-icon icon-voted"></div></div>
                        <div class="control-button status-button" data-status="deleted" onclick="toggleStatus(this, ${playerNum}, 'deleted')"><div class="control-icon icon-deleted"></div></div>
                    </div>
                    <div class="control-row role-row">
                        <div class="control-button role-button" data-role="red" onclick="toggleRole(this, ${playerNum}, 'red')"><div class="control-icon icon-heart"></div></div>
                        <div class="control-button role-button" data-role="sher" onclick="toggleRole(this, ${playerNum}, 'sher')"><div class="control-icon icon-sher"></div></div>
                        <div class="control-button role-button" data-role="don" onclick="toggleRole(this, ${playerNum}, 'don')"><div class="control-icon icon-don"></div></div>
                        <div class="control-button role-button" data-role="black" onclick="toggleRole(this, ${playerNum}, 'black')"><div class="control-icon icon-black"></div></div>
                    </div>

                </div>
                <div class="player-checks">
                    <div class="checks-title">Проверки:</div>
                    <div class="checks-container" id="checks-container-${playerNum}"></div>
                    <div class="player-select-container">
                        <select class="player-select check-player-select" data-player-num="${playerNum}"></select>
                    </div>
                </div>
                <div class="player-guess">
                    <div class="guess-title">Лучший ход:</div>
                    <div class="guess-container" id="guess-container-${playerNum}"></div>
                    <div class="player-select-container" id="guess-select-container-${playerNum}">
                        <select class="player-select guess-player-select" data-player-num="${playerNum}"></select>
                    </div>
                </div>
            `;
            return card;
        }

        function updatePlayersData(gameInfo) {
            if (gameInfo.players && gameInfo.players.length > 0) {
                gameInfo.players.forEach((player, index) => {
                    if (index < 10) {
                        const playerNum = index + 1;
                        const nameElement = document.getElementById(`player-name-${playerNum}`);
                        const playerCard = document.querySelector(`.player-card[data-player-num="${playerNum}"]`);

                        if (nameElement) {
                            nameElement.textContent = player.nickname;
                            nameElement.dataset.nickname = player.nickname; // Важно для toggleStatus/Role
                        }

                        // Сброс активных кнопок и классов перед обновлением
                        playerCard.querySelectorAll('.role-button.active, .status-button.active, .speaker.active')
                            .forEach(btn => btn.classList.remove('active'));
                        playerCard.className = 'player-card'; // Сброс классов роли/статуса с карточки

                        if (player.role) {
                            const roleBtn = playerCard.querySelector(`.role-button[data-role="${player.role}"]`);
                            if (roleBtn) roleBtn.classList.add('active');
                            playerCard.classList.add(`role-${player.role}`);
                        }
                        if (player.status) {
                            const statusBtn = playerCard.querySelector(`.status-button[data-status="${player.status}"]`);
                            if (statusBtn) statusBtn.classList.add('active');
                            playerCard.classList.add(`status-${player.status}`);
                        }
                        if (player.speaker) {
                            const speakerBtn = playerCard.querySelector(`.speaker`);
                            if (speakerBtn) speakerBtn.classList.add('active');
                        }

                        // REQ 3: Update client-side store and re-render checks/guesses
                        playerSpecificData[playerNum].checks = Array.isArray(player.checks) ? [...player.checks] : [];
                        playerSpecificData[playerNum].guesses = Array.isArray(player.guess) ? [...player.guess] : [];
                        renderPlayerChecks(playerNum);
                        renderPlayerGuesses(playerNum);
                    }
                });
            }
        }

        function updateGameSettings(gameInfo) {
            if (gameInfo.visibleOverlay !== undefined) document.getElementById('toggle-panel').checked = gameInfo.visibleOverlay;
            if (gameInfo.visibleRoles !== undefined) document.getElementById('toggle-roles').checked = gameInfo.visibleRoles;
            if (gameInfo.visibleScores !== undefined) document.getElementById('toggle-scores').checked = gameInfo.visibleScores;
            if (gameInfo.started !== undefined) document.getElementById('toggle-started').checked = gameInfo.started;
            if (gameInfo.text) document.getElementById('game-title').value = gameInfo.text;
            if (gameInfo.delay !== undefined) document.getElementById('game-delay').value = gameInfo.delay;
        }

        // Глобализация для HTML onclick
        window.toggleStatus = toggleStatus;
        window.toggleRole = toggleRole;
        window.toggleSpeaker = toggleSpeaker;
        // REQ 3: Глобализация новых обработчиков для onclick
        window.handlePlayerCheckRemove = handlePlayerCheckRemove;
        window.handlePlayerGuessRemove = handlePlayerGuessRemove;
    }); // Конец DOMContentLoaded

    // --- Функции взаимодействия с UI и бэкендом ---

    async function toggleStatus(button, playerNum, status) {
        const playerCard = button.closest('.player-card');
        const wasActive = button.classList.contains('active');
        const currentActiveStatusButton = playerCard.querySelector('.status-button.active');

        // Определяем, какой статус нужно отправить на бэкенд
        let statusToSend = status;
        if (wasActive) { // Если кнопка уже была активна (повторное нажатие)
            statusToSend = null; // Отправляем null для сброса
        }

        const playerName = document.getElementById(`player-name-${playerNum}`).dataset.nickname;
        if (!playerName) { // Проверка, чтобы не отправлять для пустых игроков
            console.warn(`Player ${playerNum} has no nickname. Status change aborted.`);
            return;
        }

        try {
            const response = await fetch(`/${id}/status`, {
                method: 'POST',
                body: JSON.stringify({[playerNum]: statusToSend}),
                headers: {'Content-Type': 'application/json'}
            });

            if (!response.ok) {
                alert(`Ошибка обновления статуса для игрока ${playerNum}. Статус: ${response.status}`);
                return; // Не меняем UI, если бэкенд вернул ошибку
            }

            // Обновляем UI только после успешного ответа
            // Снимаем активность со всех кнопок статуса
            playerCard.querySelectorAll('.status-button').forEach(btn => {
                btn.classList.remove('active');
                playerCard.classList.remove(`status-${btn.dataset.status}`);
            });

            if (!wasActive) { // Если кнопка не была активна, активируем ее
                button.classList.add('active');
                playerCard.classList.add(`status-${status}`);
            }
            // Если была активна (wasActive = true), то класс active уже снят, и новый не добавляется - статус сброшен.

        } catch (error) {
            alert(`Сетевая ошибка при обновлении статуса для игрока ${playerNum}.`);
            console.error('Error toggleStatus:', error);
        }
    }

    async function toggleRole(button, playerNum, role) {
        const playerCard = button.closest('.player-card');
        const wasActive = button.classList.contains('active');
        let roleToSend = role;
        if (wasActive) {
            roleToSend = ''; // Пустая строка для сброса роли
        }

        const playerName = document.getElementById(`player-name-${playerNum}`).dataset.nickname;
        if (!playerName) {
            console.warn(`Player ${playerNum} has no nickname. Role change aborted.`);
            return;
        }

        try {
            const response = await fetch(`/${id}/roles`, {
                method: 'POST',
                body: JSON.stringify({[playerNum]: roleToSend}),
                headers: {'Content-Type': 'application/json'}
            });

            if (!response.ok) {
                alert(`Ошибка обновления роли для игрока ${playerNum}. Статус: ${response.status}`);
                return;
            }

            playerCard.querySelectorAll('.role-button').forEach(btn => {
                btn.classList.remove('active');
                playerCard.classList.remove(`role-${btn.dataset.role}`);
            });
            if (!wasActive) {
                button.classList.add('active');
                playerCard.classList.add(`role-${role}`);
            }
        } catch (error) {
            alert(`Сетевая ошибка при обновлении роли для игрока ${playerNum}.`);
            console.error('Error toggleRole:', error);
        }
    }

    async function toggleSpeaker(button, playerNum) {
        const isActive = button.classList.contains('active');
        const playerNumberToSend = isActive ? '' : `?playerNum=${playerNum}`; // Если активен, отключаем (пустой), иначе включаем

        try {
            const response = await fetch(`/${id}/setSpeaker${playerNumberToSend}`, {method: 'POST'});
            if (!response.ok) {
                alert(`Ошибка установки говорящего. Статус: ${response.status}`);
                return;
            }

            document.querySelectorAll('.speaker.active').forEach(btn => btn.classList.remove('active'));
            if (!isActive) {
                button.classList.add('active');
            }
        } catch (error) {
            alert('Сетевая ошибка при установке говорящего.');
            console.error('Error toggleSpeaker:', error);
        }
    }

    // --- REQ 3: Функции для проверок (Checks) ---
    function renderPlayerChecks(playerNum) {
        const checksContainer = document.getElementById(`checks-container-${playerNum}`);
        if (!checksContainer) return;
        checksContainer.innerHTML = ''; // Очищаем перед рендерингом

        const checks = playerSpecificData[playerNum]?.checks || [];
        checks.forEach((check, index) => {
            const checkElement = document.createElement('div');
            // Предполагаем, что 'check' это объект {num: X, result: 'red'/'black'/undefined}
            // или просто номер, если результат еще не известен
            const checkNum = typeof check === 'object' ? check.num : check;
            const checkResult = typeof check === 'object' ? check.result || '' : '';

            checkElement.className = `check-item ${checkResult}`;
            checkElement.innerHTML = `${checkNum} <button onclick="handlePlayerCheckRemove(${playerNum}, ${index})">×</button>`;
            checksContainer.appendChild(checkElement);
        });
    }

    async function handlePlayerCheckAdd(playerNum, targetPlayerNum) {
        if (!playerSpecificData[playerNum]) {
            playerSpecificData[playerNum] = {
                checks: [],
                guesses: []
            };
        }
        // Добавляем объект, чтобы потом сервер мог добавить 'result'
        playerSpecificData[playerNum].checks.push({num: targetPlayerNum});
        renderPlayerChecks(playerNum); // Обновляем UI немедленно
        await sendPlayerChecksToServer(playerNum);
    }

    async function handlePlayerCheckRemove(playerNum, checkIndex) {
        if (playerSpecificData[playerNum] && playerSpecificData[playerNum].checks[checkIndex]) {
            playerSpecificData[playerNum].checks.splice(checkIndex, 1);
            renderPlayerChecks(playerNum);
            await sendPlayerChecksToServer(playerNum);
        }
    }

    async function sendPlayerChecksToServer(playerNum) {
        const checksForServer = playerSpecificData[playerNum].checks.map(chk => (typeof chk === 'object' ? chk.num : chk));

        try {
            // Убедитесь, что этот эндпоинт (`/setPlayerChecks`) ожидает массив номеров или объектов
            const response = await fetch(`/${id}/setPlayerChecks`, {
                method: 'POST',
                body: JSON.stringify({
                    playerNum: playerNum,
                    targetPlayerNums: checksForServer
                }),
                headers: {'Content-Type': 'application/json'}
            });
            if (!response.ok) {
                alert(`Ошибка сохранения проверок для игрока ${playerNum}. Статус: ${response.status}. Рекомендуется обновить страницу.`);
                // Здесь можно добавить логику отката или повторной загрузки gameInfo
            }
            // Можно ожидать обновленный gameInfo или только список проверок в ответе,
            // и обновить playerSpecificData[playerNum].checks и перерисовать, если сервер вернул данные с результатами.
            // Например, если сервер возвращает { checks: [{num: X, result: 'red'}, ...] }
            // const updatedData = await response.json();
            // if (updatedData && updatedData.checks) {
            //    playerSpecificData[playerNum].checks = updatedData.checks;
            //    renderPlayerChecks(playerNum);
            // }

        } catch (error) {
            alert(`Сетевая ошибка при сохранении проверок для игрока ${playerNum}.`);
            console.error('Error sendPlayerChecksToServer:', error);
        }
    }

    // --- REQ 3: Функции для лучших ходов (Guesses) ---
    function renderPlayerGuesses(playerNum) {
        const guessContainer = document.getElementById(`guess-container-${playerNum}`);
        const guessSelectContainer = document.getElementById(`guess-select-container-${playerNum}`);
        if (!guessContainer || !guessSelectContainer) return;

        guessContainer.innerHTML = '';
        const guesses = playerSpecificData[playerNum]?.guesses || [];
        guesses.forEach((guess, index) => {
            const guessElement = document.createElement('div');
            guessElement.className = 'guess-item';
            // Предполагаем, что 'guess' это объект {num: X} или просто номер
            const guessNum = typeof guess === 'object' ? guess.num : guess;
            guessElement.innerHTML = `${guessNum} <button onclick="handlePlayerGuessRemove(${playerNum}, ${index})">×</button>`;
            guessContainer.appendChild(guessElement);
        });

        if (guesses.length >= 3) {
            guessSelectContainer.classList.add('hidden');
        } else {
            guessSelectContainer.classList.remove('hidden');
        }
    }

    async function handlePlayerGuessAdd(playerNum, targetPlayerNum) {
        if (!playerSpecificData[playerNum]) {
            playerSpecificData[playerNum] = {
                checks: [],
                guesses: []
            };
        }
        if (playerSpecificData[playerNum].guesses.length < 3) {
            playerSpecificData[playerNum].guesses.push({num: targetPlayerNum}); // Добавляем как объект
            renderPlayerGuesses(playerNum);
            await sendPlayerGuessesToServer(playerNum);
        } else {
            alert('Можно указать не более 3-х лучших ходов.');
        }
    }

    async function handlePlayerGuessRemove(playerNum, guessIndex) {
        if (playerSpecificData[playerNum] && playerSpecificData[playerNum].guesses[guessIndex]) {
            playerSpecificData[playerNum].guesses.splice(guessIndex, 1);
            renderPlayerGuesses(playerNum);
            await sendPlayerGuessesToServer(playerNum);
        }
    }

    async function sendPlayerGuessesToServer(playerNum) {
        const guessesForServer = playerSpecificData[playerNum].guesses.map(g => (typeof g === 'object' ? g.num : g));
        try {
            // Убедитесь, что этот эндпоинт (`/setPlayerGuesses`) ожидает массив номеров или объектов
            const response = await fetch(`/${id}/setPlayerGuesses`, {
                method: 'POST',
                body: JSON.stringify({
                    playerNum: playerNum,
                    targetPlayerNums: guessesForServer
                }),
                headers: {'Content-Type': 'application/json'}
            });
            if (!response.ok) {
                alert(`Ошибка сохранения лучших ходов для игрока ${playerNum}. Статус: ${response.status}. Рекомендуется обновить страницу.`);
            }
            // Аналогично проверкам, можно обновить данные с сервера, если он их возвращает.
        } catch (error) {
            alert(`Сетевая ошибка при сохранении лучших ходов для игрока ${playerNum}.`);
            console.error('Error sendPlayerGuessesToServer:', error);
        }
    }

</script>
</body>
</html>
